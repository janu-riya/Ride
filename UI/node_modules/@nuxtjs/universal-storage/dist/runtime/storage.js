import Vue from "vue";
import getProp from "dotprop";
import {parse as parseCookie, serialize as serializeCookie} from "cookie";
export class Storage {
  constructor(ctx, options) {
    this.ctx = ctx;
    this.options = options;
    this._initState(options.initialState);
  }
  setUniversal(key, value) {
    this.setState(key, value);
    this.setCookie(key, value);
    this.setLocalStorage(key, value);
    return value;
  }
  getUniversal(key) {
    let value = this.getState(key);
    if (isUnset(value)) {
      value = this.getCookie(key);
    }
    if (isUnset(value)) {
      value = this.getLocalStorage(key);
    }
    return value;
  }
  syncUniversal(key, defaultValue) {
    let value = this.getUniversal(key);
    if (isUnset(value) && isSet(defaultValue)) {
      value = defaultValue;
    }
    if (isSet(value)) {
      this.setUniversal(key, value);
    }
    return value;
  }
  removeUniversal(key) {
    this.removeState(key);
    this.removeLocalStorage(key);
    this.removeCookie(key);
  }
  _initState(initData) {
    Vue.set(this, "_state", {});
    this._useVuex = this.options.vuex && this.ctx.store;
    if (this._useVuex) {
      const storeModule = {
        namespaced: true,
        state: () => ({}),
        mutations: {
          SET(state, payload) {
            Vue.set(state, payload.key, payload.value);
          }
        }
      };
      this.ctx.store.registerModule(this.options.vuex.namespace, storeModule, {
        preserveState: Boolean(this.ctx.store.state[this.options.vuex.namespace])
      });
      this.state = this.ctx.store.state[this.options.vuex.namespace];
    } else {
      Vue.set(this, "state", {});
    }
    for (const key in initData) {
      this.syncUniversal(key, initData[key]);
    }
  }
  setState(key, value) {
    if (key[0] === "_") {
      Vue.set(this._state, key, value);
    } else if (this._useVuex) {
      this.ctx.store.commit(this.options.vuex.namespace + "/SET", {
        key,
        value
      });
    } else {
      Vue.set(this.state, key, value);
    }
    return value;
  }
  getState(key) {
    if (key[0] !== "_") {
      return this.state[key];
    } else {
      return this._state[key];
    }
  }
  watchState(key, fn) {
    if (this._useVuex) {
      return this.ctx.store.watch((state) => getProp(state[this.options.vuex.namespace], key), fn);
    }
  }
  removeState(key) {
    this.setState(key, void 0);
  }
  setLocalStorage(key, value) {
    if (typeof localStorage === "undefined" || !this.options.localStorage) {
      return;
    }
    const _key = this.options.localStorage.prefix + key;
    try {
      if (isObjectOrArray(value)) {
        localStorage.setItem(_key, JSON.stringify(value));
      } else {
        localStorage.setItem(_key, value);
      }
    } catch (e) {
      if (!this.options.ignoreExceptions) {
        throw e;
      }
    }
    return value;
  }
  getLocalStorage(key) {
    if (typeof localStorage === "undefined" || !this.options.localStorage) {
      return;
    }
    const _key = this.options.localStorage.prefix + key;
    const value = localStorage.getItem(_key);
    return decodeValue(value);
  }
  removeLocalStorage(key) {
    if (typeof localStorage === "undefined" || !this.options.localStorage) {
      return;
    }
    const _key = this.options.localStorage.prefix + key;
    localStorage.removeItem(_key);
  }
  getCookies() {
    const cookieStr = process.client ? document.cookie : this.ctx.req.headers.cookie;
    return parseCookie(cookieStr || "") || {};
  }
  setCookie(key, value, options = {}) {
    if (!this.options.cookie) {
      return;
    }
    const _key = this.options.cookie.prefix + key;
    const _options = Object.assign({}, this.options.cookie.options, options);
    const _value = encodeValue(value);
    const serializedCookie = serializeCookie(_key, _value, _options);
    if (process.client) {
      document.cookie = serializedCookie;
    } else if (process.server && this.ctx.res) {
      this.ctx.res.setHeader("Set-Cookie", [serializedCookie]);
    }
    return value;
  }
  getCookie(key) {
    if (!this.options.cookie || process.server && !this.ctx.req) {
      return;
    }
    const _key = this.options.cookie.prefix + key;
    const cookies = this.getCookies();
    const value = cookies[_key] ? decodeURIComponent(cookies[_key]) : void 0;
    return decodeValue(value);
  }
  removeCookie(key, options) {
    this.setCookie(key, void 0, {maxAge: -1, ...options});
  }
}
function isUnset(o) {
  return typeof o === "undefined" || o === null;
}
function isSet(o) {
  return !isUnset(o);
}
function isObjectOrArray(obj) {
  const type = Object.prototype.toString.call(obj);
  return type === "[object Object]" || type === "[object Array]";
}
function encodeValue(val) {
  if (typeof val === "string") {
    return val;
  }
  return JSON.stringify(val);
}
function decodeValue(val) {
  const type = Object.prototype.toString.call(val);
  if (type === "[object Object]") {
    return val;
  }
  if (type === "undefined") {
    return val;
  }
  try {
    return JSON.parse(val);
  } catch (error) {
    return val;
  }
}
